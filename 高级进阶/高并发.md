# 多线程

# 缓存

# 降级

# 限流
## 漏桶算法
漏桶算法描述：一个固定容量的漏桶按照常量固定速率流出水滴，如果桶是空的，不需要流出水滴，可以以任务速率流入水滴到漏桶，如果流入水滴超出了桶的容量，则将流入的水滴溢出，漏桶的容量保持不变。

图示：
![漏桶算法图示](https://github.com/kongdou/tech-docs/blob/master/images/Leaky%20Bucket.png)

### 特点
- 以核定的速率服务请求，限制数据的传输速率
- 无法应对突发流量，容易导致溢出

### 代码实现
待补充

## 令牌桶算法
令牌桶算法描述：以固定的速率生产令牌，请求是否需要处理，主要看桶中是否有令牌，如果没有令牌则拒绝访问，如存在令牌允许访问，这意味着面对瞬时大流量，该算法可以在短时间内拿到大量令牌，而且拿令牌的过程并不消耗太多资源

图示：
![令牌桶图示](https://github.com/kongdou/tech-docs/blob/master/images/Token%20Bucket.png)

### 特点
- 可以应对突发流量，面对瞬间大流量，可以在短时间内获得大量令牌
- 流量整形（控制令牌生产速率）

### 开源工具
Guava RateLimiter

### 代码实现
待补充



### volatile
volatile是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。  

可见性的意思是当一个线程 修改一个共享变量时，另外一个线程能读到这个修改的值。  

volatiled变量修饰符比sychronized更轻量级，因为不涉及线程上下文切换。  

Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。  

>内存屏障：一组处理器指令，用于实现对内存的顺序限制。  

volatile的两条实现原则：  
1. Lock前缀指令会引起处理器缓存回写到内存
2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效

volatile的使用优化：  


# 锁
Java6中，锁一共有4种状态：
- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态

这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏 向锁升级成轻量级锁后不能降级成偏向锁，不能降级的策略是为了提高获得锁和释放锁的效率

## 偏向锁
大多数情况下，锁不仅不存在多线程竞争，而且总是由同 一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。  

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出 同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否 存储着指向当前线程的偏向锁。
- 如果测试成功，表示线程已经获得了锁
- 如果测试失败，则需 要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。

偏向锁的撤销，它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着， 如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈 会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他 线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

# Java如何实现原子操作
## 使用循环CAS实现原子操作
JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的

## CAS实现原子操作的三大问题
（1）ABA问题
因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化 则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它 的值没有发生变化，但是实际上却变化了。  

ABA问题的解决思路就是使用版本号。

Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。  

这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是 否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

（2）循环时间长开销大  
