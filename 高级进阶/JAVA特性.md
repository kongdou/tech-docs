# Java New一个对象分配多少内存

# CountDownLatch(1.5引入)
CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 

CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。 

https://blog.csdn.net/scandly_java/article/details/51333231


# CyclicBarrier(1.5引入)

# Semaphore(1.5引入)

# concurrentHashMap(1.5引入)

# BlockingQueue(1.5引入)
阻塞队列，java.util.concurrent 包里的 BlockingQueue 接口表示一个线程放入和提取实例的队列。

阻塞队列与非阻塞队列一个最大的区别就是：阻塞队列能够阻塞当前试图从队列中获取元素的线程，而非阻塞队列不会。因此在面对类似消费者-生产者的模型时，使用非阻塞队列就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。但是有了阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。

- ArrayBlockingQueue
- LinkedBlockingQueue
- PriorityBlockingQueue
- DelayQueue
- SynchronousQueue
- DelayedWorkQueue
- BlockingDeque
- TransferQueue

## LinkedBlockingQueue()
有界队列

# AtomicInteger

# volatile

# PriorityQueue


# ArrayDeque

String.intern()

# ReentrantLock
公平锁和非公平锁

## 为什么使用FIFO会存在非公平的情况？
先进入队列的会比后进入的线程更靠近头部，那么它将比后者更早的被唤醒，它也就能更早的得到锁。从这个意义上,对于在同步队列中等待的线程而言,它们获得锁的顺序和加入同步队列的顺序一致，这显然是一种公平模式。为什么是非公平的，因为线程并非只有在加入队列后才有机会获得锁，在进入队列之前会有两次抢占锁的机会

- 第一次是非重入式的获取锁,只有在当前锁未被任何线程占有(包括自身)时才能成功;
- 第二次是在进入同步队列前,包含所有情况的获取锁的方式。

只有这两次获取锁都失败后,线程才会构造结点并加入同步队列等待。

而线程释放锁时是先释放锁(修改state值),然后才唤醒后继结点的线程的。所以在修改state后和唤醒阻塞线程之前，会有线程抢到锁，如：

线程A已经释放锁,但还没来得及唤醒后继线程C,而这时另一个线程B刚好尝试获取锁,此时锁恰好不被任何线程持有,它将成功获取锁而不用加入队列等待。线程C被唤醒尝试获取锁,而此时锁已经被线程B抢占,故而其获取失败并继续在队列中等待。

如果以线程第一次尝试获取锁到最后成功获取锁的次序来看,非公平锁确实很不公平。因为在队列中等待很久的线程相比还未进入队列等待的线程并没有优先权,甚至竞争也处于劣势:在队列中的线程要等待其他线程唤醒,在获取锁之前还要检查前驱结点是否为头结点。在锁竞争激烈的情况下,在队列中等待的线程可能迟迟竞争不到锁。这也就非公平在高并发情况下会出现的饥饿问题。那我们再开发中为什么大多使用会导致饥饿的非公平锁？因为性能好


## 为什么非公平锁性能好
非公平锁对锁的竞争是抢占式的(队列中线程除外),线程在进入等待队列前可以进行两次尝试,这大大增加了获取锁的机会。这种好处体现在两个方面:
1. 线程不必加入等待队列就可以获得锁,不仅免去了构造结点并加入队列的繁琐操作,同时也节省了线程阻塞唤醒的开销,线程阻塞和唤醒涉及到线程上下文的切换和操作系统的系统调用,是非常耗时的。在高并发情况下,如果线程持有锁的时间非常短,短到线程入队阻塞的过程超过线程持有并释放锁的时间开销,那么这种抢占式特性对并发性能的提升会更加明显。
2. 减少CAS竞争。如果线程必须要加入阻塞队列才能获取锁,那入队时CAS竞争将变得异常激烈,CAS操作虽然不会导致失败线程挂起,但不断失败重试导致的对CPU的浪费也不能忽视。除此之外,加锁流程中至少有两处通过将某些特殊情况提前来减少CAS操作的竞争,增加并发情况下的性能。一处就是获取锁时将非重入的情况提前,如下图所示

```
        final void lock() {
            if (compareAndSetState(0, 1))//此处
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
```
另一处就是入队的操作,将同步队列非空的情况提前处理  
```
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            //将Node节点加到队列尾
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
```
![reentrantlock](https://github.com/kongdou/tech-docs/blob/master/images/reentrantlock.png)





## 使用场景
(1)如果发现该操作已经在执行中则不再执行  
- 用在定时任务时，如果任务执行时间可能超过下次计划执行时间，确保该有状态任务只有一个正在执行，忽略重复触发
- 用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）

(2)如果发现该操作已经在执行，等待一个一个执行 
这种比较常见大家也都在用，主要是防止资源使用冲突，保证同一时间内只有一个操作可以使用该资源。   
但与synchronized的明显区别是性能优势（伴随jvm的优化这个差距在减小）。同时Lock有更灵活的锁定方式，公平锁与不公平锁，而synchronized永远是公平的。  

（3）如果发现该操作已经在执行，则尝试等待一段时间，等待超时则不执行（尝试等待执行）  

（4）如果发现该操作已经在执行，等待执行。这时可中断正在进行的操作立刻释放锁继续下一操作



## lock和tryLock区别
tryLock不管拿到拿不到都直接返回；lock如果拿不到则会一直等待。  
tryLock是可以中断的。