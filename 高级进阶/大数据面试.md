# JVM
Java虚拟机主要由字节码指令集、寄存器、栈、垃圾回收堆和存储方法域等构成，JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

## JVM生命周期
JVM伴随着Java程序的开始而开始，程序的结束而结束。一个Java程序会开启一个JVM进程，一台计算机上可以运行多个程序，也就是可以运行多个JVM进程。

JVM线程分为两种，守护线程和普通线程。守护线程是JVM自己使用的线程，比如GC就是一个守护线程，普通线程就是一般的Java程序线程，只要JVM中有普通的线程在运行，Java虚拟机就不会停止

## 即时编译（JIT）
什么是JIT?

日常所谓的Java编译是指前端编译，也就是通过javac编译，将.java文件编译成.class文件，这个过程中**javac并不做性能优化，只会做语法检查**。  
而后端编译指的是将**字节码**转换成操作系统可以执行的**机器码**，这个过程采用混合的方法，包括**解释执行**和**编译执行**，其中编译执行就是所谓的
JIT。

### 分层编译模式
HotSpot虚拟机有多个即时编译器，C1（Client Compiler）和C2（Server Compiler），最新的还有Graal即时编译器。  
Java7 之前，对于**启动性能要求高的，选择C1启动编译器，对应参数-client**，对于**性能要求高的，选择C2启动编译器，对应参数-server**  
Java7 开始，引入了分层编译：对应参数-XX:+tieredCompilation，它综合了C1的启动优势和C2巅峰性能优势，也可以通过参数-server和-client强制指定虚拟的即时编译模式  

分层编译将jvm的执行状态分为五个层次：
- 第0层：程序解释执行，默认开启性能监控（profiling），如果不开启，可触发第二层编译
- 第1层：可称为C1编译，将字节码转译为本地代码，进行简单、可靠的优化，不开启profiling
- 第2层：也称为C1编译，开启profiling，仅执行带有方法调用次数和循环回编执行次数的profiling的C1编译
- 第3层：也称为C1编译，执行所有带profiling的C1编译
- 第4层：可称为C2编译，也是将字节码转译为机器码（本地代码），但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化

对于C1的三种状态，按照执行效率从高到低：第1层、第2层、第3层  
通常情况下，C2的执行效率比C1高30%以上  

在java8中，默认使用了分层编译，-client和-server的设置都已经是无效的，如果只想开启C2，关闭分层编译即可，-XX+TieredCompilation，如果只想使用C1，可以在打开分层编译的同时，使用参数+XX:TieredStoreAtLevel=1  

查看系统的编译模式：  
java -version  
`
java version "1.8.0_131"  
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)  
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)  
`

## JVM内存模型

主要由**堆内存**、**方法区**、**程序计数器**、**虚拟机栈**和**本地方法栈**组成。其组成结构如下：
![内存模型](https://github.com/kongdou/tech-docs/blob/master/images/JVM虚拟机内存模型.png)

其中**堆**和**方法区**是所有线程共有的，而**虚拟机栈**、**本地方法栈**和**程序计数器**是线程私有的

### 堆内存
堆内存是所有线程共有的，可以分为两部分：年轻代和老年代，另外注意**永久代并不属于堆内存的一部分**，并且在1.8版本以后被移除
(https://github.com/kongdou/tech-docs/blob/master/images/heap.png)

堆内存是我们在生产环境中进行内存性能调优中的一个重要的内容，内存回收的一些机制和算法。

#### 内存回收机制和算法
##### JVM回收那个区域的


### 方法区
方法区与Java堆一样，是各个线程共享的区域，它用于存储已被虚拟机加载的类信息，如常量、静态变量





## GC

# 设计模式

# 